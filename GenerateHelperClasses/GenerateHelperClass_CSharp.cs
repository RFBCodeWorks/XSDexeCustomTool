using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;

namespace XSDCustomToolVSIX
{
    class GenerateHelperClass_CSharp : GenerateHelperClass_Base
    {

        public GenerateHelperClass_CSharp(XSD_Instance xsdSettings) : base(xsdSettings) { }

        public override string OutputClassName => xSD_Instance.InputFile.Name.Replace(".xsd", "_HelperClass");
        public string NameSpace => xSD_Instance.XSDexeOptions.NameSpace;

        public override FileInfo FileOnDisk => new FileInfo(base.xSD_Instance.InputFile.FullName.Replace(".xsd", "_HelperClass.cs"));

        protected override string CommentIndicator => "//";

        protected override SourceClass[] ParseLoop(string[] txt, int StartIndex)
        {
            
            int? OpenBracketIndex = null; int OpenBracketCount = 0; int ClosedBracketCount = 0; int i = StartIndex;
            string className = null;
            List<string> classText = new List<string> { };
            List<SourceClass_CSharp> DiscoveredClasses = new List<SourceClass_CSharp> { };
            SourceClass_CSharp[] nestedClasses = new SourceClass_CSharp[0] { };

            while ( i <= txt.Length )
            {
                string ln = txt[i];
                
                if (ln.Contains("partial class"))
                {
                    if (className is null)
                    {
                        //Setup the ClassName and reset the bracket counters
                        className = ExtractClassNameFromLine(ln);
                        OpenBracketIndex = i;
                        OpenBracketCount = 0;
                        ClosedBracketCount = 0;
                    }
                    else
                        nestedClasses = (SourceClass_CSharp[])ParseLoop(txt, i); // Found an inner class -> begin parsing for that class.
                }
                if (className != null) classText.Add(ln);
                OpenBracketCount += ln.Count( c => c == '{' ); // the first instance of should be on the start of the class.
                ClosedBracketCount += ln.Count( c => c == '}' );
                if (OpenBracketCount == ClosedBracketCount & className != null)
                {
                    // this should be the end of the class in question
                    SourceClass_CSharp @class = new SourceClass_CSharp(className, classText.ToArray());
                    @class.InnerClasses.AddRange(nestedClasses?.ToList());
                    DiscoveredClasses.Add(@class);
                    className = null;
                }
                else if (OpenBracketCount < ClosedBracketCount) // hit more than closed brackets than open brackets -> end of file.
                    return DiscoveredClasses.ToArray();
                i++;
            }
            return DiscoveredClasses.ToArray();

        }

        private string ExtractClassNameFromLine(string LineText)
        {
            string[] arr = LineText.Split(' ');
            int expectedlocation = arr.ToList().IndexOf("class");
            if (expectedlocation > 0) return arr[expectedlocation +1 ]; //public partial class [classname]
            throw new Exception("Unexpected! - Output did not conform to expected format.");
        }
        

        public override void Generate()
        {
            ReadInClassFile();
            string txt = "";
            txt += "using System;\n";
            txt += "using System.IO;\n";
            txt += "using System.Xml.Serialization;\n\n";
            txt += base.GetComment_AutoGen();
            txt += $"namespace {this.NameSpace} {{\n\n"; // NameSpace
            txt += $"{TabLevel(1)}/// <summary>Helper class to ease working with {this.xSD_Instance.InputFile.Name} autogenerated {(IsGeneratingClass? "class" : "dataset")}</summary>\n";
            txt += $"{TabLevel(1)}public partial class {this.OutputClassName} {{\n\n";
            txt += RegionWrap(GenerateConstructors(2), "Constructors", 2);
            txt += RegionWrap(GenerateProperties(2), "Properties", 2);
            txt += RegionWrap(GetClassLoaderMethod(2) + GetClassSaverMethod(2), "Saving & Loading XML Files", 2);
            txt += $"{TabLevel(1)}}}\n"; // Close out the class 
            txt += $"}}"; // Close out the namespace
            //Write to file
            base.Save(txt);
        }

        private static string RegionWrap(string inputTxt, string RegionName, int BaseIndentLevel)
        {
            string txt = $"{VSTools.TabIndent(BaseIndentLevel)}#region < {RegionName} >\n\n";
            txt += inputTxt;
            txt += $"{VSTools.TabIndent(BaseIndentLevel)}#endregion </ {RegionName} >\n\n";
            return txt;
        }

        /// <summary></summary>
        /// <param name="BaseIndentLevel"></param>
        /// <returns></returns>
        protected override string GenerateConstructors(int BaseIndentLevel)
        {
            string NoArgs = String.Concat(
                $"{VSTools.TabIndent(BaseIndentLevel)}/// <summary> Construct a new instance of the {OutputClassName} object. </summary>\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}public {OutputClassName}()\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}{{\n",
                $"{VSTools.TabIndent(BaseIndentLevel + 1)} // TO DO: assign values for all the properties\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}}}\n\n"
                );

            string FilePathArg = String.Concat(
                $"{VSTools.TabIndent(BaseIndentLevel)}/// <summary> Construct a new instance of the {OutputClassName} object by Deserializing an XML file. </summary>\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}/// <param name=\"FilePath\"> This XML file to read into the class object </param>\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}public {OutputClassName}(string FilePath)\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}{{\n",
                $"{VSTools.TabIndent(BaseIndentLevel + 1)} {TopLevelClass.HelperClass_PropertyName} = Load(FilePath);\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}}}\n\n"
                );

            string DeserializedXML = String.Concat(
                $"{VSTools.TabIndent(BaseIndentLevel)}/// <summary> Construct a new instance of the {OutputClassName} object from an existing <typeparamref name=\"{TopLevelClass.ClassName}\"/> object. </summary>\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}/// <param name=\"{TopLevelClass.HelperClass_PropertyName.ToLower()}\"> A pre-existing <typeparamref name=\"{TopLevelClass.ClassName}\"/> object.</param>\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}public {OutputClassName}({TopLevelClass.ClassName} {TopLevelClass.HelperClass_PropertyName.ToLower()})\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}{{\n",
                $"{VSTools.TabIndent(BaseIndentLevel + 1)} {TopLevelClass.HelperClass_PropertyName} = {TopLevelClass.HelperClass_PropertyName.ToLower()};\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}}}\n\n"
                );

            return String.Concat(NoArgs, FilePathArg, DeserializedXML);
        }

        /// <summary></summary>
        /// <param name="BaseIndentLevel"></param>
        /// <returns></returns>
        protected string GenerateProperties(int BaseIndentLevel)
        {
            List<string> PropertyList = new List<string>();
            PropertyList.Add(TopLevelClass.GetPropertyString(BaseIndentLevel));
            foreach (SourceClass cl in this.DiscoveredClasses)
                if (cl != TopLevelClass)
                    if (!cl.ClassName.Contains(TopLevelClass.ClassName))
                        PropertyList.Add(cl.GetPropertyString(BaseIndentLevel));

            string ret = "";
            foreach (string s in PropertyList)
                ret += s + "\n\n";
            
            return ret;

        }

        /// <summary> Generate a Load(string) method to deserialize an XML file into this helper class. </summary>
        /// <returns></returns>
        protected override string GetClassLoaderMethod(int BaseIndentLevel)
        {

            string Comments = GetComment_LoadMethod(BaseIndentLevel);

            string Method = String.Concat(
                $"{VSTools.TabIndent(BaseIndentLevel)}public static {TopLevelClass.ClassName} Load(string FilePath) {{\n",
                    $"{VSTools.TabIndent(BaseIndentLevel + 1)}{TopLevelClass.ClassName} retObj = null;\n",
                    $"{VSTools.TabIndent(BaseIndentLevel + 1)}try {{\n");
            if (IsGeneratingClass)
            {
                Method = String.Concat(Method,
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}using (Stream stream = File.Open(FilePath, FileMode.Open)) {{\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}XmlSerializer serializer = new XmlSerializer(typeof({TopLevelClass.ClassName}));\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}retObj = ({TopLevelClass.ClassName})serializer.Deserialize(stream);\n",
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}}}\n");
            } else if (IsGeneratingDataSet)
            {
                // Must use DataSet.ReadXML to load into the class.
                throw new NotImplementedException("Testing with DataSets not done yet!");
                Method = String.Concat(Method,
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}using (Stream stream = File.Open(FilePath, FileMode.Open)) {{\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}XmlSerializer serializer = new XmlSerializer(typeof({TopLevelClass.ClassName}));\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}retObj = ({TopLevelClass.ClassName})serializer.Deserialize(stream);\n",
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}}}\n");
            }
            Method = String.Concat(Method,
                $"{VSTools.TabIndent(BaseIndentLevel + 1)}}} catch (Exception E) {{\n",
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}throw new NotImplementedException(\"Catch Statement Not Implemented. See Inner Error.\", E);\n",
                    $"{VSTools.TabIndent(BaseIndentLevel + 1)}}}\n",
                    $"{VSTools.TabIndent(BaseIndentLevel + 1)}return retObj;\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}}}\n\n"
                );
            return String.Concat(Comments, Method);
        }

        /// <summary> Generate a Save(string) method to serialize an XML file from this class. </summary>
        /// <returns></returns>
        protected override string GetClassSaverMethod(int BaseIndentLevel)
        {
            string Comments = base.GetComment_SaveMethod(BaseIndentLevel);

            string Method = String.Concat(
                $"{VSTools.TabIndent(BaseIndentLevel)}public void SaveXMLFile(string FilePath) {{\n",
                    $"{VSTools.TabIndent(BaseIndentLevel + 1)}try {{\n",
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}Directory.CreateDirectory(new FileInfo(FilePath).DirectoryName);\n");
            if (IsGeneratingClass)
            {
                Method = String.Concat(Method,
                $"{VSTools.TabIndent(BaseIndentLevel + 2)}using (Stream stream = File.Open(FilePath, FileMode.Create)) {{\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}XmlSerializer serializer = new XmlSerializer(typeof({TopLevelClass.ClassName}));\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}serializer.Serialize(stream, this.{TopLevelClass.HelperClass_PropertyName});\n",
                            $"{VSTools.TabIndent(BaseIndentLevel + 3)}stream.Flush();\n",
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}}}\n");
            } else if (IsGeneratingDataSet)
            {
                // Save DataSet to xml
                // Use WriteXml to write the document.
                //OriginalDataSet.WriteXml(xmlFilename);
            }
            Method = String.Concat(Method,
                $"{VSTools.TabIndent(BaseIndentLevel + 1)}}} catch (Exception E) {{\n",
                        $"{VSTools.TabIndent(BaseIndentLevel + 2)}throw new NotImplementedException(\"Catch Statement Not Implemented. See Inner Error.\", E);\n",
                    $"{VSTools.TabIndent(BaseIndentLevel + 1)}}}\n",
                $"{VSTools.TabIndent(BaseIndentLevel)}}}\n\n"
                );
            return String.Concat(Comments, Method);
        }

        /// <summary>Generate the Class Tree of nested helper classes within this helper class</summary>
        /// <param name="BaseIndentLevel"></param>
        /// <returns></returns>
        protected override string GenerateClassTree(int BaseIndentLevel) => TopLevelClass.BuildClassTree(BaseIndentLevel);

    }
    
    class SourceClass_CSharp : SourceClass
    {
        /// <inheritdoc cref="SourceClass.SourceClass(string)"/>
        public SourceClass_CSharp(string className, string[] classText) : base(className, classText) { }

        /// <inheritdoc cref="SourceClass.SourceClass(string, bool)"/>
        public SourceClass_CSharp(string className, string[] classText, bool isTopLevelNode) : base(className, classText, isTopLevelNode) { }

        public override Enums.SupportedLanguages ClassLanguage => Enums.SupportedLanguages.CSharp;

        /// <returns>"{Public/Private} {ClassName} {PropertyName} {get;set;}"</returns>
        /// <inheritdoc cref="GetPropertyString(int, bool)"/>
        public override string GetPropertyString(int IndentLevel, bool IsPublic = true)
            => $"{VSTools.TabIndent(IndentLevel)}/// <summary>  </summary>\n" +
            $"{VSTools.TabIndent(IndentLevel)}{(IsPublic ? "public" : "private")} {ClassName} {HelperClass_PropertyName} {{ get; {(IsPublic ? "private " : "")}set; }}";

        /// <inheritdoc cref="GetConstructors(int)"/>
        public override string GetConstructors(int IndentLevel) => $"{VSTools.TabIndent(IndentLevel)}public {this.ClassName}() {{}}";

        /// <inheritdoc cref="BuildClassTree(int)"/>
        public override string BuildClassTree(int IndentLevel)
        {
            string properties = String.Empty;
            string nested = String.Empty;

            foreach (SourceClass IC in InnerClasses)
                properties = String.Concat(properties, IC.GetPropertyString(IndentLevel + 1), Environment.NewLine);

            foreach (SourceClass IC in InnerClasses)
                nested = String.Concat(nested, IC.BuildClassTree(IndentLevel + 1), Environment.NewLine);

            string thisclass = String.Concat(
                $"{VSTools.TabIndent(IndentLevel)}#region < {this.ClassName} >\n",
                this.GetConstructors(IndentLevel + 1), Environment.NewLine,

                $"{VSTools.TabIndent(IndentLevel)}#region < Nested Class Objects Properties >\n",
                properties, Environment.NewLine,
                $"{VSTools.TabIndent(IndentLevel)}#endregion </ Nested Class Objects Properties >\n", Environment.NewLine,

                $"{VSTools.TabIndent(IndentLevel)}#region < Nested Classes >\n",
                nested, Environment.NewLine,
                $"{VSTools.TabIndent(IndentLevel)}#endregion </ Nested Classes >\n",

                $"{VSTools.TabIndent(IndentLevel)}#endregion </ {this.ClassName} >"
                );

            return thisclass;
        }

    }
}
