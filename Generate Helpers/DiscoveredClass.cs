using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.CodeDom;
using System.CodeDom.Compiler;

namespace XSDCustomToolVSIX.Generate_Helpers
{
    /// <summary> This represents a class that was discovered when evaluting the output file from XSD.exe </summary>
    internal abstract class DiscoveredClass
    {
        private DiscoveredClass() { }

        /// <summary> Setup the object with a className. This constructor makes an object assumed to be a child element. </summary>
        /// <param name="parsedFile"><inheritdoc cref="ParsedFile" path="*"/></param>
        /// <param name="className"><inheritdoc cref="ClassName" path="*"/></param>
        /// <param name="startIndex"><inheritdoc cref="StartIndex" path="*"/></param>
        /// <param name="endIndex"><inheritdoc cref="EndIndex" path="*"/></param>
        /// <param name="hasConstructor"><inheritdoc cref="ContainsParameterLessConstructor" path="*"/></param>
        public DiscoveredClass(ParsedFile parsedFile, string className, int startIndex, int endIndex, bool hasConstructor)
        {
            this.ParsedFile = parsedFile;
            this.ClassName = className;
            this.StartIndex = startIndex;
            this.EndIndex = endIndex;
            this.ContainsParameterLessConstructor = hasConstructor;
            Members.ad
        }

        public DiscoveredClass(CodeTypeDeclaration ClassDeclaration)
        {
            this.Class = ClassDeclaration;
            foreach (CodeTypeMember member  in  Class.Members)
            {
                member.Attributes = .
            }
        }

        /// <inheritdoc cref="CodeTypeDeclaration" />
        protected CodeTypeDeclaration Class { get; }

        /// <inheritdoc cref="CodeTypeMember" />
        protected CodeTypeMemberCollection Members => Class.Members.;

        

        #region < Properties >

        internal bool IsTopLevelNode { get; }

        /// <summary>Reference to the ParseFile object this DiscoveredClass was generated from</summary>
        internal ParsedFile ParsedFile { get; }

        #region < ClassText Property >

        /// <summary> Index of the line in the ParsedFile where this class Begins </summary>
        private int StartIndex;
        /// <summary>  Index of the line in the ParsedFile where this class Ends </summary>
        private int EndIndex;

        /// <summary>
        /// Get the ClassText from the <see cref="ParsedFile.FileText"/> property as a string[]
        /// </summary>
        internal protected string[] ClassText
        {
            get
            {
                Span<string> rng = new Span<string>(ParsedFile.FileText, StartIndex, EndIndex - StartIndex);
                return rng.ToArray();
            }
        }

        #endregion </ Class Text >

        /// <summary> This is the name of the class (the 'type' of the class.)</summary>
        public string ClassName { get; private set; }

        /// <summary> The class may have multiple inner classes. These are defined in a list here. </summary>
        public List<DiscoveredClass> InnerClasses { get; } = new List<DiscoveredClass>();

        /// <summary> Any properties discovered while parsing the class will be listed here. </summary>
        public List<DiscoveredProperty> ClassProperties { get; } = new List<DiscoveredProperty>();

        /// <summary>If an autogenerated constructor was found during parsing, this value will be true</summary>
        internal bool ContainsParameterLessConstructor { get; }

        #endregion </ Properties >

        #region < Overridable Properties >

        internal abstract Enums.SupportedLanguages ClassLanguage { get; }
        
        /// <summary> This is the characeter found at the end of commands. Ex: C# will return ';' </summary>
        internal abstract string EndOfLineChar { get; }

        /// <summary> This is the name of the property within the Helper class. </summary>
        /// <returns>Base property returns the <see cref="DiscoveredClass.ClassName"/></returns>
        public virtual string HelperClass_PropertyName => this.ClassName;

        #endregion

        #region < Abstract Methods >

        /// <summary>Get the string that represents this class as a property of within the HelperClass</summary>
        /// <param name="IndentLevel"></param>
        /// <param name="IsPublic">set TRUE to return a Public Property, set FALSE to return a Private property</param>
        internal abstract string GetPropertyString(int IndentLevel, bool IsPublic = true);

        /// <summary>Get the string that for the parameterless constructor that initializes all properties. <br/>
        /// This will be used when building the Supplement File if [<c><see cref="DiscoveredClass.ContainsParameterLessConstructor"/></c>] is false</summary>
        /// <param name="BaseIndentLevel"></param>
        /// <returns> Class() {} </returns>
        internal abstract string GetConstructor(int BaseIndentLevel);

        /// <summary> Runs the appropriate method based on the selected output language. </summary>
        /// <param name="BaseIndentLevel"></param>
        /// <returns>
        /// A string that represents a tree of nested classes, starting with the class object that called this method <br/>
        /// Example:   <br/>class Caller{   <br/>
        /// _     NestedClass_1 PropertyName {get;} <br/>
        /// _     NestedClass_2 PropertyName {get;} <br/>
        /// _     class NestedClass_1{}  <br/>
        /// _     class NestedClass_2{}  <br/> 
        /// }
        /// </returns>
        //internal abstract string BuildClassTree(int BaseIndentLevel);

        #endregion </ Abstract Methods >
    }
}
