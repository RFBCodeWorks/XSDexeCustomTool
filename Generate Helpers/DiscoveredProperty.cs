using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace XSDCustomToolVSIX.Generate_Helpers
{
    /// <summary>
    /// Represents the discovered Property of a class
    /// </summary>
    internal class DiscoveredProperty
    {
        internal DiscoveredProperty() { }

        internal DiscoveredProperty(string Name, string Type, bool isGeneratedClassType, bool isSerializable)
        {
            this.Name = Name;
            this.Type = Type;
            this.IsGeneratedClassType = isGeneratedClassType;
            this.IsSerializable = isSerializable;
        }

        #region < Properties >

        private DiscoveredClass ParentClassField;
        private string NameField;
        private string TypeField;
        private string[] AttributesField;
        private bool ReadOnlyField;
        private bool IsSerializableField;
        private bool IsGeneratedClassTypeField;
        private bool IsPropertyField;

        
        internal bool IsField => !IsPropertyField;

        internal protected DiscoveredClass ParentClass
        {
            get => ParentClassField;
            set { if (!ReadOnlyField) ParentClassField = value; }
        }

        internal bool IsProperty {
            get => IsPropertyField;
            set { if (!ReadOnlyField) IsPropertyField = value; }
        }

        /// <summary> Name of the Property </summary>
        internal string Name {
            get => NameField;
            set { if (!ReadOnlyField) NameField = value; }
        }

        /// <summary> Type of property </summary>
        internal string Type {
            get => TypeField;
            set { if (!ReadOnlyField) TypeField = value; }
        }

        /// <summary>
        /// Once set true, the object becomes ReadOnly.
        /// </summary>
        internal bool ReadOnly { 
            get => ReadOnlyField; 
            set {  if (!ReadOnlyField) ReadOnlyField = value; }
        }

        /// <summary> Is this property of a type that was generated by xsd.exe </summary>
        internal bool IsGeneratedClassType { 
            get => IsGeneratedClassTypeField;
            set { if (!ReadOnlyField) IsGeneratedClassTypeField = value; }
        }

        /// <summary>String List of the attributes detected for this property</summary>
        internal string[] Attributes {
            get => AttributesField;
            set { if (!ReadOnlyField) AttributesField = value; }
        }

        /// <summary>
        /// Flag for if the property is a serializable (Determined by attribute above the property)
        /// </summary>
        internal bool IsSerializable { 
            get => IsSerializableField;
            set { if (!ReadOnlyField) IsSerializableField = value; }
        }

        #endregion < Properties >

        /// <summary>
        /// Switch Statement that checks for common types and returns the initializer. <br/>
        /// This relies on the overridable <see cref="_GetBoolInit"/> methods to return the initializer in the correct format for the language.
        /// </summary>
        /// <param name="TabLevel"></param>
        /// <param name="IncludeNewLineAtEnd"></param>
        /// <returns>
        /// [PropertyName] = [ResultOfInitMethod] <br/>
        /// For example: String types return: { <c>[PropertyName] = String.Empty;</c> } where ';' is set by <see cref="DiscoveredClass.EndOfLineChar"/>
        /// </returns>
        internal protected virtual string GetProperyInitializer(int TabLevel, bool IncludeNewLineAtEnd = true)
        {
            string init;
            switch (this.Type.ToLower())
            {
                case "string": 
                    init = _GetStringInit();
                    break;
                case "int": case "long":
                    init = _GetIntInit();
                    break;
                case "bool": case "boolean":
                    init = _GetBoolInit();
                    break;
                default:
                    init = _GetClassInit();
                    break;
            }
            return $"{VSTools.TabIndent(TabLevel)}{this.Name} = {init}{(IncludeNewLineAtEnd? Environment.NewLine : String.Empty)}";
        }

        /// <summary>Overrideable Method to use when getting the property initializer for a STRING type property </summary>
        /// <returns>String.Empty{<see cref="DiscoveredClass.EndOfLineChar"/>}</returns>
        protected virtual string _GetStringInit() => $"String.Empty{ParentClass.EndOfLineChar}";

        /// <summary>Overrideable Method to use when getting the property initializer for a BOOL type property </summary>
        /// <returns>false{<see cref="DiscoveredClass.EndOfLineChar"/>}</returns>
        protected virtual string _GetBoolInit() => $"false{ParentClass.EndOfLineChar}";

        /// <summary>Overrideable Method to use when getting the property initializer for a INT type property </summary>
        /// <returns>0{<see cref="DiscoveredClass.EndOfLineChar"/>}</returns>
        protected virtual string _GetIntInit() => $"0{ParentClass.EndOfLineChar}";

        /// <summary>Overrideable Method to use when getting the property initializer for a CLASS type properties </summary>
        /// <returns><code>$"new {DiscoveredProperty.Type}(){ParentClass.EndOfLineChar}"</code></returns>
        protected virtual string _GetClassInit() => $"new {this.Type}(){ParentClass.EndOfLineChar}";

    }
}
