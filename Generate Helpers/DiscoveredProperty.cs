using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.CodeDom;
using System.CodeDom.Compiler;

namespace XSDCustomToolVSIX.Generate_Helpers
{
    /// <summary>
    /// Represents the discovered Property of a class
    /// </summary>
    internal class DiscoveredProperty
    {
        internal DiscoveredProperty() { }

        internal DiscoveredProperty(CodeMemberProperty ClassMember, CodeMemberField BackingField)
        {
            BaseProperty = ClassMember;
            BaseField = BackingField;
        }

        #region < Properties >

        
        private CodeMemberProperty BaseProperty;
        private CodeMemberField BaseField;

        private DiscoveredClass ParentClassField;
        private bool ReadOnlyField;
        private bool IsSerializableField;


        /// <summary>  </summary>
        /// <remarks><inheritdoc cref="CodeTypeMember.Attributes" path="*"/></remarks>
        internal MemberAttributes Attributes => BaseProperty?.Attributes ?? BaseField.Attributes;

        internal bool IsPublic => Attributes == MemberAttributes.Public;
        internal bool IsPrivate => Attributes == MemberAttributes.Private;

        ///<inheritdoc cref="CodeTypeMember.Name"/>
        internal string Name => BaseProperty?.Name ?? BaseField?.Name ?? "UNKOWN";

        ///<inheritdoc cref="CodeTypeReference.BaseType"/>
        internal string Type => BaseProperty?.Type?.BaseType ?? BaseField?.Type?.BaseType ?? "UNKOWN_TYPE";

        /// <inheritdoc cref="CodeMemberProperty.HasSet"/>
        internal bool HasSetter => BaseProperty?.HasSet ?? BaseField != null;

        /// <summary> If TRUE: The Member is a Property </summary>
        internal bool IsProperty => BaseProperty != null;
        
        /// <summary> If TRUE: The Member is a Field </summary>
        internal bool IsField => !IsProperty;

        internal protected DiscoveredClass ParentClass
        {
            get => ParentClassField;
            set { if (!ReadOnlyField) ParentClassField = value; }
        }

        /// <summary> Flag for if the property is a serializable (Determined by attribute above the property) </summary>
        internal bool IsSerializable { 
            get => IsSerializableField;
            set { if (!ReadOnlyField) IsSerializableField = value; }
        }
        
        #endregion < Properties >

        #region < Boolean Properties >
        
        /// <summary> Is this property of a type that was generated by xsd.exe </summary>
        internal bool IsGeneratedType => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.Name == this.Type);

        /// <summary> Is this property of an ENUM type that was generated by xsd.exe </summary>
        internal bool IsGeneratedEnum => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.IsEnum && d.Name == this.Type);

        /// <summary> Is this property of an CLASS type that was generated by xsd.exe </summary>
        internal bool IsGeneratedClass => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.IsClass && d.Name == this.Type);

        #endregion < Properties >

        // https://docs.microsoft.com/en-us/dotnet/api/system.codedom.codeexpressionstatement?view=windowsdesktop-5.0
        /// <summary>
        /// Getthe Initializer for this Property / Field for use inthe Supplement's constructor
        /// </summary>
        internal protected virtual CodeAssignStatement GetSupplementInitializer()
        {
            
            CodeExpression left = new CodeVariableReferenceExpression(this.Name);
            CodeExpression right;
            switch (this.Type.ToLower())
            {
                case "string":
                    right = new CodePrimitiveExpression(String.Empty);
                    break;
                case "int":
                case "long":
                    right = new CodePrimitiveExpression(0);
                    break;
                case "bool":
                case "boolean":
                    right = new CodePrimitiveExpression(false);
                    break;
                default:
                    if (IsGeneratedType && IsGeneratedEnum)
                        return null; // Not bothering  with this right now
                    else if (IsGeneratedType && IsGeneratedClass)
                        right = new CodeObjectCreateExpression(this.Type);
                    //CodeArrayCreateExpression 
                    else
                        right = new CodePrimitiveExpression(null);
                    break;
            }
            return new CodeAssignStatement(left,right);
        }
    }
}
