using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;
using XSDCustomToolVSIX.Generate_Helpers;
using System.CodeDom;

namespace XSDCustomToolVSIX
{ 
    /// <summary>
    /// Contains the CodeDomCompileUnit read by the <see cref="LanguageProvider"/>, and contains references to the additionalCode Generators.
    /// </summary>
    internal class ParsedFile
    {
        #region < Class Factory >

        private ParsedFile() { }
        protected  ParsedFile(XSD_Instance xsdInstance) 
        { 
            this.xSD_Instance = xsdInstance;
            LazyParsedCode = new Lazy<CodeCompileUnit>(() => ReadInClassFile());
            LazyDiscoveredClasses = new Lazy<DiscoveredClass[]>(() => GetDiscoveredClasses());
            LazyDiscoveredEnums = new Lazy<DiscoveredEnum[]>(() => GetDiscoveredEnums());
            TopLevelClassAssumption = new Lazy<DiscoveredClass>( () => DiscoveredClasses[0] );
        }

        internal static ParsedFile ParsedFileFactory(XSD_Instance xSD)
        {
            ParsedFile output = null;
            switch (xSD.XSDexeOptions.Language)
            {
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.CS:
                    output = new ParsedFile_CSharp(xSD);
                    output.HelperClass = new CodeGenerator_HelperClass(output);
                    output.Supplement = new CodeGenerator_SupplementFile(output);
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VB:
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.JS:
                default:
                    output = new ParsedFile(xSD);
                    output.HelperClass = new CodeGenerator_HelperClass(output);
                    output.Supplement = new CodeGenerator_SupplementFile(output);
                    break;
            }
            output.LanguageProvider = output.GetCodeDomProvider();
            return output;

            
        }

        /// <summary></summary>
        /// <returns></returns>
        private System.CodeDom.Compiler.CodeDomProvider GetCodeDomProvider()
        {
            string lang  = System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(this.xSD_Instance.OutputFile.Extension);
            switch (this.xSD_Instance.XSDexeOptions.Language)
            {
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.CS:return new Microsoft.CSharp.CSharpCodeProvider();
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VB: return new Microsoft.VisualBasic.VBCodeProvider();
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.JS: return new Microsoft.JScript.JScriptCodeProvider();
                default:
                    throw new NotImplementedException("Unknown Language Type - Must use language that specifies System.CodeDom.Compiler.CodeDomProvider");
            }
            
        }

        #endregion </ Class Factory >

        #region < Properties >

        private readonly Lazy<CodeCompileUnit> LazyParsedCode;
        private readonly Lazy<DiscoveredClass[]> LazyDiscoveredClasses;
        private readonly Lazy<DiscoveredEnum[]> LazyDiscoveredEnums;
        private readonly Lazy<DiscoveredClass> TopLevelClassAssumption; //Assume that first class found is top level class
        private DiscoveredClass TopLevelClassField = null;

        #region < CodeDom - Lanugage Parse & Provider >

        /// <summary>
        /// This is the CodeDomProvider that provides the syntax for generating code for the provider's language.
        /// </summary>
        internal System.CodeDom.Compiler.CodeDomProvider LanguageProvider { get; private set; }

        /// <summary>
        /// The resulting <see cref="System.CodeDom.CodeCompileUnit"/> unit that represents the code generated by XSD.exe
        /// </summary>
        internal System.CodeDom.CodeCompileUnit ParsedCode => LazyParsedCode.Value;

        /// <summary>
        /// Contains all <see cref="System.CodeDom.CodeTypeDeclaration"/> objects found when parsing the file generated by XSD.exe
        /// </summary>
        internal System.CodeDom.CodeTypeDeclarationCollection DiscoveredTypes => ParsedCode?.Namespaces[0]?.Types;

        /// <inheritdoc cref="System.CodeDom.Compiler.CodeDomProvider.FileExtension"/>
        internal virtual string OutputFileExtension => LanguageProvider.FileExtension;

        internal System.CodeDom.Compiler.CodeGeneratorOptions CodeGeneratorOptions { get; }
            = new System.CodeDom.Compiler.CodeGeneratorOptions {  BlankLinesBetweenMembers = true };

        #endregion < CodeDom - Lanugage Parse & Provider >

        /// <summary> HelperClass File Generator </summary>
        internal protected CodeGenerator_HelperClass HelperClass { get; private set; }
        
        /// <summary> AutoGenerated_Supplement File Generator </summary>
        internal protected CodeGenerator_SupplementFile Supplement { get; private set; }

        /// <summary> DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. </summary>
        internal protected DiscoveredClass[] DiscoveredClasses => LazyDiscoveredClasses.Value;

        /// <summary> DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. </summary>
        internal protected DiscoveredEnum[] DiscoveredEnums=> LazyDiscoveredEnums.Value;

        /// <summary> <see cref="ReadInClassFile"/> sets the first class found as the TopLevelClass, though this may be incorrect. </summary>
        internal protected DiscoveredClass TopLevelClass 
        { 
            get => TopLevelClassField ?? TopLevelClassAssumption.Value;
            protected set => this.TopLevelClassField = value; 
        }

        #region < XSD_Instance -- Settings for helpers and the output of XSD.exe >

        /// <summary> This is the instance of XSD settings to work with. </summary>
        public XSD_Instance xSD_Instance { get; }

        ///<inheritdoc cref="XSD_Instance.OutputFile"/>
        protected FileInfo GeneratedFile => xSD_Instance.OutputFile;

        internal bool IsGeneratingClass => xSD_Instance.IsGeneratingClass;
        
        internal bool IsGeneratingDataSet => xSD_Instance.IsGeneratingDataSet;

        #endregion < XSD_Instance -- Settings for helpers and the output of XSD.exe >

        #endregion </ Properties >

        #region < ReadInClassFile >

        /// <summary>
        /// Read in the class file into the ParsedCode property.
        /// </summary>
        /// <returns>Returns a CodeCompileUnit from the parsed code </returns>
        protected virtual CodeCompileUnit ReadInClassFile()
        {
            CodeCompileUnit tmp;
            using (TextReader rdr = GeneratedFile.OpenText())
            {
                tmp = LanguageProvider.Parse(rdr);
            }
            return tmp;
        }

        /// <summary>
        /// Create the array of DiscoveredClasses
        /// </summary>
        /// <returns></returns>
        DiscoveredClass[] GetDiscoveredClasses()
        {
            List<DiscoveredClass> list = new List<DiscoveredClass>();
            foreach (CodeTypeDeclaration type in ParsedCode.Namespaces[0].Types.Where( (CodeTypeDeclaration d)=> d.IsClass))
            {
                list.Add(new DiscoveredClass(type));
            }
            return list.ToArray();
        }

        /// <summary>
        /// Create the array of DiscoveredEnums
        /// </summary>
        /// <returns></returns>
        DiscoveredEnum[] GetDiscoveredEnums()
        {
            List<DiscoveredEnum> list = new List<DiscoveredEnum>();
            foreach (CodeTypeDeclaration type in ParsedCode.Namespaces[0].Types.Where((CodeTypeDeclaration d) => d.IsEnum))
            {
                list.Add(new DiscoveredEnum(type));
            }
            return list.ToArray();
        }

        #endregion </ ReadInClassFile >

    }
}
