using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;
using XSDCustomToolVSIX.Generate_Helpers;
using XSDCustomToolVSIX.Generate_Helpers.CSharp;

namespace XSDCustomToolVSIX
{ 
    /// <summary>
    /// Contains the Instructions to parse the file generated by XSD.exe and the resulting objects discovered from parsing. <br/>
    /// </summary>
    /// <remarks>
    /// Also contains various methods and properties that can be overriden per language if needed, such as <see cref="RegionWrap(string, string, int)"/>
    /// and <see cref="TabLevel(int)"/>
    /// </remarks>
    internal abstract class ParsedFile
    {
        #region < Class Factory >

        private ParsedFile() { }
        protected  ParsedFile(XSD_Instance xsdInstance) 
        { 
            this.xSD_Instance = xsdInstance; 
            LazyFileText = new Lazy<string[]>( () => this.ReadInClassFile() );
            LazyDiscoveredClasses = new Lazy<DiscoveredClass[]>( () => ParseLoop() );
            TopLevelClassAssumption = new Lazy<DiscoveredClass>( () => DiscoveredClasses[0] );
        }

        internal static ParsedFile ParsedFileFactory(XSD_Instance xSD)
        {
            ParsedFile output = null;
            switch (xSD.XSDexeOptions.Language)
            {
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.CS:
                    output = new ParsedFile_CSharp(xSD);
                    output.HelperClass = new HelperClass_CSharp(output);
                    output.Supplement = new AutoGenSupplement_CSharp(output);
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VB:
                    //output = new ParsedFile_VB(xSD);
                    //output.HelperClass = new HelperClass_VB(output);
                    //output.Supplement = new AutoGenSupplement_VB(output);
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.JS:
                    //output = new ParsedFile_JavaScript(xSD);
                    //output.HelperClass = new HelperClass_JavaScript(output);
                    //output.Supplement = new AutoGenSupplement_JavaScript(output);
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VJS:
                    //I can't test this!
                    break;
            }
            return output;
        }

        #endregion </ Class Factory >

        #region < Properties >

        private Lazy<string[]> LazyFileText; //Read the class file in only once, on first demand.
        private readonly Lazy<DiscoveredClass[]> LazyDiscoveredClasses; //Call the ParseLoop function one needed
        private readonly Lazy<DiscoveredClass> TopLevelClassAssumption; //Assume that first class found is top level class
        private DiscoveredClass TopLevelClassField = null;


        /// <summary> HelperClass File Generator </summary>
        internal protected HelperClass HelperClass { get; private set; }
        
        /// <summary> AutoGenerated_Supplement File Generator </summary>
        internal protected AutoGenSupplement Supplement { get; private set; }

        /// <summary> DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. </summary>
        internal protected DiscoveredClass[] DiscoveredClasses => LazyDiscoveredClasses.Value;

        /// <summary> <see cref="ReadInClassFile"/> sets the first class found as the TopLevelClass, though this may be incorrect. </summary>
        internal protected DiscoveredClass TopLevelClass 
        { 
            get => TopLevelClassField ?? TopLevelClassAssumption.Value;
            protected set => this.TopLevelClassField = value; 
        }

        /// <summary> File text read from the file generated by XSD.exe </summary>
        internal protected string[] FileText => LazyFileText.Value;

        #region < XSD_Instance -- Settings for helpers and the output of XSD.exe >

        /// <summary> This is the instance of XSD settings to work with. </summary>
        public XSD_Instance xSD_Instance { get; }

        ///<inheritdoc cref="XSD_Instance.OutputFile"/>
        protected FileInfo GeneratedFile => xSD_Instance.OutputFile;

        internal bool IsGeneratingClass => xSD_Instance.IsGeneratingClass;
        
        internal bool IsGeneratingDataSet => xSD_Instance.IsGeneratingDataSet;

        #endregion < XSD_Instance -- Settings for helpers and the output of XSD.exe >

        /// <summary> 
        /// Get the Extension to use when writing the Helper and Supplement files. <br/>
        /// Base method returns the same extension as the file generated by XSD.exe.
        /// </summary>
        internal virtual string OutputFileExtension => Path.GetExtension(GeneratedFile.Name);

        #endregion </ Properties >

        #region < Overridable Properties >

        /// <summary>The character string used to let the compiler know this is the start of a Summary line</summary>
        /// <remarks>For example, C# will return:  "///" since the syntax is " <c>/// &lt;summary&gt;</c> " </remarks>
        internal protected abstract string SummaryIndicator { get; }

        /// <summary>The character string used to let the compiler know this is the start of a comment line</summary>
        /// <remarks>For example, C# will return:  "//" </remarks>
        internal protected abstract string CommentIndicator { get; }

        
        #endregion </ Overridable Properties >

        #region < ReadInClassFile >

        /// <summary>
        /// Read in the class file. The ParseLoop method is called from here.
        /// This will then store the DiscoveredClasses output by the parse loop into to the DiscoveredClasses and TopLevelClass properties.
        /// </summary>
        private string[] ReadInClassFile()
        {
            List<string> fileText = new List<string> { };
            string ln;
            //Read the file into memory
            using (StreamReader rdr = GeneratedFile.OpenText())
            {
                ParsedCode = LanguageProvider.Parse(rdr);
                do
                {
                    ln = rdr.ReadLine();
                    fileText.Add(ln);
                } while (ln != null);
            }
            return fileText.ToArray();

                // System.CodeDom.CodeTypeMember; Methods/ Properties / fields
                // System.CodeDom.CodeTypeDeclaration CLASSES & ENUMS

                DiscoveredTypes[0].


        }

        System.CodeDom.Compiler.CodeDomProvider LanguageProvider;
        Microsoft.CSharp.CSharpCodeProvider CSharpCodeProvider => new Microsoft.CSharp.CSharpCodeProvider();
        System.CodeDom.CodeCompileUnit ParsedCode;

        System.CodeDom.CodeTypeDeclarationCollection DiscoveredTypes => ParsedCode?.Namespaces[0]?.Types;
        System.CodeDom.CodeTypeDeclarationCollection DiscoveredClasses => ParsedCode?.Namespaces[0]?.Types;

        #endregion </ ReadInClassFile >

        #region < Overridable Methods >

        /// <summary>
        /// The ParseLoop function is called by <see cref="ParsedFile.ReadInClassFile"/>, and is used to parse the read text then return an array of DiscoveredClasses
        /// </summary>
        /// <param name="txt"></param>
        /// <param name="StartIndex"></param>
        /// <returns>Array of DiscoveredClasses found within the file generated by xsd.exe</returns>
        protected abstract DiscoveredClass[] ParseLoop();

        /// <summary>Check an input line to determine if it is in the syntax that indicates the start of a class.</summary>
        /// <param name="Line">Line read from the output of XSD.exe</param>
        /// <returns>TRUE if the line is the follows the syntax for the start of a class.</returns>
        protected abstract bool IsLine_ClassStart(string Line);

        /// <summary>Check an input line to determine if it is in the syntax that indicates the line is a constructor</summary>
        /// <param name="Line">Line read from the output of XSD.exe</param>
        /// <param name="ClassName">Name of the class currently being parsed</param>
        /// <returns>TRUE if the line is a constructor, otherwise false.</returns>
        protected abstract bool IsLine_ClassConstructor(string Line, string ClassName);

        /// <summary>
        /// Parse a line and attempt to initialize a new DiscoveredProperty object. This should only work if the line has the name and type included.
        /// </summary>
        /// <param name="Line">Line to parse</param>
        /// <param name="newProp">Output a new Property. If returning false, prop should be null.</param>
        /// <returns>Returns TRUE if a new property was parsed from the line.</returns>
        protected abstract bool TryCreateProperty(string Line, out DiscoveredProperty newProp);

        /// <summary>
        /// Extract the Class Name from the input line. Used after the <see cref="IsLine_ClassStart(string)"/> returns true to retrieve the class name.
        /// </summary>
        /// <param name="Line"></param>
        /// <returns>Class Name for the DiscoveredClass</returns>
        protected abstract string ExtractClassName(string Line);

        /// <summary>
        /// Events and Delegates are not going to have post-processing. Override if needed.
        /// </summary>
        /// <remarks>
        /// Default functionality returns TRUE if any of the following are contained within the string: <br/>
        /// - void <br/>
        /// - delegate <br/>
        /// - event <br/>
        /// </remarks>
        /// <param name="Line"></param>
        /// <returns></returns>
        protected virtual bool IsLine_EventOrDelegate(string Line) => Line.ToLower().Contains("void") || Line.ToLower().Contains("event") || Line.ToLower().Contains("delegate");

        #endregion </ Overridable Methods >
    }
}
