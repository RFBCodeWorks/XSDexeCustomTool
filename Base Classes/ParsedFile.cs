using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;
using XSDCustomToolVSIX.Generate_Helpers;
using System.CodeDom;

namespace XSDCustomToolVSIX
{
    /// <summary>
    /// Contains the CodeDomCompileUnit read by the <see cref="LanguageProvider"/>, and contains references to the additionalCode Generators.
    /// </summary>
    internal class ParsedFile
    {
        #region < Class Factory >

        private ParsedFile() { }
        protected ParsedFile(XSD_Instance xsdInstance)
        {
            this.xSD_Instance = xsdInstance;
            LazyParsedCode = new Lazy<CodeCompileUnit>(() => ReadInClassFile());
            LazyDiscoveredClasses = new Lazy<DiscoveredClass[]>(() => GetDiscoveredClasses());
            LazyDiscoveredEnums = new Lazy<DiscoveredEnum[]>(() => GetDiscoveredEnums());
            TopLevelClassAssumption = new Lazy<DiscoveredClass>(() => DiscoveredClasses[0]);
        }

        internal static ParsedFile ParsedFileFactory(XSD_Instance xSD)
        {
            ParsedFile output = null;
            switch (xSD.XSDexeOptions.Language)
            {
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.CS:
                    output = new ParsedFile_CSharp(xSD);
                    output.CodeDomObjectProvider = new CodeDomObjectProvider_CSharp();
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VB:
                    output = new ParsedFile_VB(xSD);
                    output.CodeDomObjectProvider = new CodeDomObjectProvider_VB();
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.JS:
                    output = new ParsedFile_JS(xSD);
                    output.CodeDomObjectProvider = new CodeDomObjectProvider_JS();
                    break;
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VJS:
                    output = new ParsedFile_JSharp(xSD);
                    output.CodeDomObjectProvider = new CodeDomObjectProvider_JSharp();
                    break;
                default:
                    output = new ParsedFile(xSD);
                    output.CodeDomObjectProvider = new CodeDomObjectProvider();
                    break;
            }
            output.LanguageProvider = output.GetCodeDomProvider();
            output.HelperClass = output.CodeDomObjectProvider.HelperClassGenerator(output);
            output.Supplement = output.CodeDomObjectProvider.SupplementFileGenerator(output);
            return output;


        }

        /// <summary></summary>
        /// <returns></returns>
        private System.CodeDom.Compiler.CodeDomProvider GetCodeDomProvider()
        {
            string lang = System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(this.xSD_Instance.OutputFile.Extension);
            switch (this.xSD_Instance.XSDexeOptions.Language)
            {
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.CS: return new Microsoft.CSharp.CSharpCodeProvider();
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VB: return new Microsoft.VisualBasic.VBCodeProvider();
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.JS: return new Microsoft.JScript.JScriptCodeProvider();
                default:
                    throw new NotImplementedException("Unknown Language Type - Must use language that specifies System.CodeDom.Compiler.CodeDomProvider");
            }

        }

        #endregion </ Class Factory >

        #region < Properties >

        private readonly Lazy<CodeCompileUnit> LazyParsedCode;
        private readonly Lazy<DiscoveredClass[]> LazyDiscoveredClasses;
        private readonly Lazy<DiscoveredEnum[]> LazyDiscoveredEnums;
        private readonly Lazy<DiscoveredClass> TopLevelClassAssumption; //Assume that first class found is top level class
        private DiscoveredClass TopLevelClassField = null;
        
        /// <inheritdoc cref="XSDCustomToolVSIX.Generate_Helpers.CodeDomObjectProvider"/>
        internal CodeDomObjectProvider CodeDomObjectProvider { get; private set; }


        #region < CodeDom - Lanugage Parse & Provider >

        /// <summary>
        /// This is the CodeDomProvider that provides the syntax for generating code for the provider's language.
        /// </summary>
        internal System.CodeDom.Compiler.CodeDomProvider LanguageProvider { get; private set; }

        /// <summary>
        /// The resulting <see cref="System.CodeDom.CodeCompileUnit"/> unit that represents the code generated by XSD.exe
        /// </summary>
        internal System.CodeDom.CodeCompileUnit ParsedCode => LazyParsedCode.Value;

        /// <summary>
        /// Contains all <see cref="System.CodeDom.CodeTypeDeclaration"/> objects found when parsing the file generated by XSD.exe
        /// </summary>
        internal System.CodeDom.CodeTypeDeclarationCollection DiscoveredTypes => this.TargetNameSpace.Types;

        /// <inheritdoc cref="System.CodeDom.Compiler.CodeDomProvider.FileExtension"/>
        internal virtual string OutputFileExtension => LanguageProvider.FileExtension;

        internal System.CodeDom.Compiler.CodeGeneratorOptions CodeGeneratorOptions { get; }
            = new System.CodeDom.Compiler.CodeGeneratorOptions { BlankLinesBetweenMembers = true };

        #endregion < CodeDom - Lanugage Parse & Provider >

        /// <summary> HelperClass File Generator </summary>
        internal protected CodeGenerator_HelperClass HelperClass { get; private set; }

        /// <summary> AutoGenerated_Supplement File Generator </summary>
        internal protected CodeGenerator_SupplementFile Supplement { get; private set; }

        /// <summary>The CodeNameSpace object that contains all the objects produced by XSD.exe </summary>
        internal protected CodeNamespace TargetNameSpace
        {
            get
            {
                if (ParsedCode != null)
                    foreach (CodeNamespace NS in ParsedCode.Namespaces)
                        if (NS.Name == xSD_Instance.XSDexeOptions.NameSpace)
                            return NS;
                return null;
            }
        }

        /// <summary> DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. </summary>
        internal protected DiscoveredClass[] DiscoveredClasses => LazyDiscoveredClasses.Value;

        /// <summary> DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. </summary>
        internal protected DiscoveredEnum[] DiscoveredEnums => LazyDiscoveredEnums.Value;

        /// <summary> <see cref="ReadInClassFile"/> sets the first class found as the TopLevelClass, though this may be incorrect. </summary>
        internal protected DiscoveredClass TopLevelClass
        {
            get => TopLevelClassField ?? TopLevelClassAssumption.Value;
            protected set => this.TopLevelClassField = value;
        }

        #region < XSD_Instance -- Settings for helpers and the output of XSD.exe >

        /// <summary> This is the instance of XSD settings to work with. </summary>
        public XSD_Instance xSD_Instance { get; }

        ///<inheritdoc cref="XSD_Instance.OutputFile"/>
        protected FileInfo GeneratedFile => xSD_Instance.OutputFile;

        internal bool IsGeneratingClass => xSD_Instance.IsGeneratingClass;

        internal bool IsGeneratingDataSet => xSD_Instance.IsGeneratingDataSet;

        #endregion < XSD_Instance -- Settings for helpers and the output of XSD.exe >

        #endregion </ Properties >

        #region < ReadInClassFile >

        /// <summary>
        /// Read in the class file into the ParsedCode property.
        /// </summary>
        /// <returns>Returns a CodeCompileUnit from the parsed code </returns>
        protected virtual CodeCompileUnit ReadInClassFile()
        {
            CodeCompileUnit tmp = new CodeCompileUnit();
            using (TextReader rdr = GeneratedFile.OpenText())
            {
                try
                {
                    tmp = LanguageProvider.Parse(rdr);
                }
                catch (Exception E)
                {
                    VSTools.WriteOutputPane(E.Message);
                }
            }
            return tmp;
        }

        protected virtual string[] ReadFileToStringArray()
        {
            string ln;
            List<string> FileText = new List<string>();
            using (StreamReader rdr = GeneratedFile.OpenText())
            {
                do
                {
                    ln = rdr.ReadLine();
                    FileText.Add(ln);
                } while (ln != null);
            }
            return FileText.ToArray();
        }

        /// <summary>
        /// <inheritdoc cref="List{T}.Find(Predicate{T})"/>
        /// </summary>
        /// <param name="name">Name to search for</param>
        /// <returns></returns>
        internal DiscoveredEnum FindEnumByName(string name) => DiscoveredEnums.FindEnumByType(name);

        /// <summary>
        /// Create the array of DiscoveredClasses
        /// </summary>
        /// <returns></returns>
        DiscoveredClass[] GetDiscoveredClasses()
        {
            List<DiscoveredClass> list = new List<DiscoveredClass>();
            foreach (CodeTypeDeclaration type in TargetNameSpace.Types.Where( (CodeTypeDeclaration d)=> d.IsClass))
            {
                list.Add(CodeDomObjectProvider.DiscoveredClassGenerator(type, this));
            }
            return list.ToArray();
        }

        /// <summary>
        /// Create the array of DiscoveredEnums
        /// </summary>
        /// <returns></returns>
        DiscoveredEnum[] GetDiscoveredEnums()
        {
            List<DiscoveredEnum> list = new List<DiscoveredEnum>();
            foreach (CodeTypeDeclaration type in TargetNameSpace.Types.Where((CodeTypeDeclaration d) => d.IsEnum))
            {
                list.Add(CodeDomObjectProvider.DiscoveredEnumGenerator(type, this));
            }
            return list.ToArray();
        }



        #endregion </ ReadInClassFile >

    }
}
