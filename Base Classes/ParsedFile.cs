using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;
using XSDCustomToolVSIX.BaseClasses;
using XSDCustomToolVSIX.Language_Specific_Overrides;
using System.CodeDom;
using XSDCustomToolVSIX.Interfaces;
using System.CodeDom.Compiler;

namespace XSDCustomToolVSIX.BaseClasses
{
    /// <summary>
    /// Contains the CodeDomCompileUnit read by the <see cref="LanguageProvider"/>, and contains references to the additionalCode Generators. <br/>
    /// The CodeCOmpileUnit represents the code generated by XSD.exe
    /// </summary>
    internal class ParsedFile : IParsedFile
    {
        #region < Class Factory >

        private ParsedFile() { }
        protected ParsedFile(IFileGenerator fileGenerator)
        {
            MasterFileGenerator = fileGenerator;
            LazyParsedCode = new Lazy<CodeCompileUnit>(() => ReadInClassFile());
            LazyDiscoveredClasses = new Lazy<DiscoveredClass[]>(() => GetDiscoveredClasses());
            LazyDiscoveredEnums = new Lazy<DiscoveredEnum[]>(() => GetDiscoveredEnums());
            TopLevelClassAssumption = new Lazy<DiscoveredClass>(() => DiscoveredClasses[0]);
        }

        internal static IParsedFile ParsedFileFactory(IFileGenerator fileGenerator)
        {
            var Lang = fileGenerator.XSD_Settings.XSDexeOptions.Language;
            switch (Lang)
            {
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.CS:
                    return new ParsedFile_CSharp(fileGenerator);
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VB:
                    return new ParsedFile_VB(fileGenerator);
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.JS:
                    return new ParsedFile_JS(fileGenerator);
                case XSDCustomTool_ParametersXSDexeOptionsLanguage.VJS:
                    return new ParsedFile_JSharp(fileGenerator);
                default:
                    return new ParsedFile(fileGenerator);
            }
        }

        #endregion </ Class Factory >

        #region < Properties >

        #region < Private Properties & References >

        private readonly Lazy<CodeCompileUnit> LazyParsedCode;
        private readonly Lazy<DiscoveredClass[]> LazyDiscoveredClasses;
        private readonly Lazy<DiscoveredEnum[]> LazyDiscoveredEnums;
        private readonly Lazy<DiscoveredClass> TopLevelClassAssumption; //Assume that first class found is top level class
        private DiscoveredClass TopLevelClassField = null;


        /// <inheritdoc cref="IFileGenerator"/>
        protected IFileGenerator MasterFileGenerator { get; }

        /// <inheritdoc cref="IFileGenerator.XSD_Settings"/>
        public XSD_Instance xSD_Instance => MasterFileGenerator.XSD_Settings;

        ///<inheritdoc cref="XSD_Instance.OutputFile"/>
        protected FileInfo GeneratedFile => xSD_Instance.OutputFile;

        /// <inheritdoc cref="ICodeDomObjectProvider"/>
        public ICodeDomObjectProvider CodeDomObjectProvider => MasterFileGenerator.CodeDomObjectProvider;

        /// <inheritdoc cref="ICodeDomObjectProvider.CodeDomProvider"/>
        public CodeDomProvider LanguageProvider => MasterFileGenerator.CodeDomObjectProvider.CodeDomProvider;

        #endregion

        #region < CodeDom - Lanugage Parse & Provider >

        /// <summary>
        /// The resulting <see cref="System.CodeDom.CodeCompileUnit"/> unit that represents the code generated by XSD.exe
        /// </summary>
        public System.CodeDom.CodeCompileUnit ParsedCode => LazyParsedCode.Value;

        /// <summary>
        /// Contains all <see cref="System.CodeDom.CodeTypeDeclaration"/> objects found when parsing the file generated by XSD.exe
        /// </summary>
        public System.CodeDom.CodeTypeDeclarationCollection DiscoveredTypes => this.TargetNameSpace.Types;

        /// <summary>
        /// The CodeNameSpace object that contains all the objects produced by XSD.exe 
        /// </summary>
        public CodeNamespace TargetNameSpace
        {
            get
            {
                if (ParsedCode != null)
                    foreach (CodeNamespace NS in ParsedCode.Namespaces)
                        if (NS.Name == xSD_Instance.XSDexeOptions.NameSpace)
                            return NS;
                return null;
            }
        }

        #endregion

        #region < Discovered Types >

        /// <summary> 
        /// DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. 
        /// </summary>
        public DiscoveredClass[] DiscoveredClasses => LazyDiscoveredClasses.Value;

        /// <summary>
        /// DiscoveredClass array set after <see cref="ReadInClassFile"/> has completed. 
        /// </summary>
        public DiscoveredEnum[] DiscoveredEnums => LazyDiscoveredEnums.Value;

        /// <summary> 
        /// <see cref="ReadInClassFile"/> sets the first class found as the TopLevelClass, though this may be incorrect. 
        /// </summary>
        public DiscoveredClass TopLevelClass
        {
            get => TopLevelClassField ?? TopLevelClassAssumption.Value;
            protected set => this.TopLevelClassField = value;
        }

        #endregion
        #endregion </ Properties >

        #region < ReadInClassFile >

        /// <summary>
        /// Read in the class file into the ParsedCode property.
        /// </summary>
        /// <returns>Returns a CodeCompileUnit from the parsed code </returns>
        protected virtual CodeCompileUnit ReadInClassFile()
        {
            CodeCompileUnit tmp = new CodeCompileUnit();
            using (TextReader rdr = GeneratedFile.OpenText())
            {
                try
                {
                    tmp = LanguageProvider.Parse(rdr);
                }
                catch (Exception E)
                {
                    VSTools.WriteOutputPane(E.Message);
                }
            }
            return tmp;
        }

        protected virtual string[] ReadFileToStringArray()
        {
            string ln;
            List<string> FileText = new List<string>();
            using (StreamReader rdr = GeneratedFile.OpenText())
            {
                do
                {
                    ln = rdr.ReadLine();
                    FileText.Add(ln);
                } while (ln != null);
            }
            return FileText.ToArray();
        }

        /// <summary>
        /// <inheritdoc cref="List{T}.Find(Predicate{T})"/>
        /// </summary>
        /// <param name="name">Name to search for</param>
        /// <returns></returns>
        public DiscoveredEnum FindEnumByName(string name) => DiscoveredEnums.FindEnumByType(name);

        /// <summary>
        /// Create the array of DiscoveredClasses
        /// </summary>
        /// <returns></returns>
        DiscoveredClass[] GetDiscoveredClasses()
        {
            List<DiscoveredClass> list = new List<DiscoveredClass>();
            foreach (CodeTypeDeclaration type in TargetNameSpace.Types.Where((CodeTypeDeclaration d) => d.IsClass))
            {
                list.Add(DiscoveredClassGenerator(type, this));
            }
            return list.ToArray();
        }

        /// <summary>
        /// Create the array of DiscoveredEnums
        /// </summary>
        /// <returns></returns>
        DiscoveredEnum[] GetDiscoveredEnums()
        {
            List<DiscoveredEnum> list = new List<DiscoveredEnum>();
            foreach (CodeTypeDeclaration type in TargetNameSpace.Types.Where((CodeTypeDeclaration d) => d.IsEnum))
            {
                list.Add(DiscoveredEnumGenerator(type, this));
            }
            return list.ToArray();
        }

        /// <summary>Override this method to create a derived DiscoveredEnum instead of the base DiscoveredEnum </summary>
        public virtual DiscoveredEnum DiscoveredEnumGenerator(CodeTypeDeclaration type, ParsedFile parsedfile) => new DiscoveredEnum(type, parsedfile);

        /// <summary>Override this method to create a derived DiscoveredClass instead of the base DiscoveredClass </summary>
        public virtual DiscoveredClass DiscoveredClassGenerator(CodeTypeDeclaration type, ParsedFile parsedfile) => new DiscoveredClass(type, parsedfile);

        /// <summary>Override this method to create a derived DiscoveredProperty instead of the base DiscoveredProperty </summary>
        public virtual DiscoveredProperty DiscoveredPropertyGenerator(CodeMemberProperty Prop, CodeMemberField backingField, DiscoveredClass parentClass) => new DiscoveredProperty(Prop, backingField, parentClass);

        #endregion </ ReadInClassFile >

    }
}
