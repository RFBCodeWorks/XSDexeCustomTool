using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.CodeDom;
using System.CodeDom.Compiler;

namespace XSDCustomToolVSIX.BaseClasses
{
    /// <summary>
    /// Represents the discovered Property of a class
    /// </summary>
    internal class DiscoveredProperty : ICodeMember
    {
        private DiscoveredProperty() { }

        internal DiscoveredProperty(System.CodeDom.CodeMemberProperty ClassMember, System.CodeDom.CodeMemberField BackingField, DiscoveredClass @ParentClass)
        {
            BaseProperty = ClassMember;
            BaseField = BackingField;
            ParentClassField = @ParentClass;
        }

        #region < Properties >

        private readonly CodeMemberProperty BaseProperty;
        private readonly CodeMemberField BaseField;
        private readonly DiscoveredClass ParentClassField;

        private CodeTypeMember PrimaryMember => (CodeTypeMember)BaseProperty ?? BaseField;
        public DiscoveredClass ParentClass => ParentClassField;

        #endregion < Properties >

        #region < Shared Members >

        /// <remarks><inheritdoc cref="CodeTypeMember.Attributes" path="*"/></remarks>
        public MemberAttributes Attributes => PrimaryMember.Attributes;

        ///<inheritdoc cref="CodeTypeMember.Name"/>
        public string Name => BaseProperty?.Name ?? BaseField?.Name ?? "UNKOWN";

        public CodeTypeReference Type => BaseProperty?.Type ?? BaseField?.Type ?? new CodeTypeReference("UnknownType");

        CodeAttributeDeclarationCollection ICodeMember.CustomAttributes => BaseProperty?.CustomAttributes ?? BaseField?.CustomAttributes;

        CodeCommentStatementCollection ICodeMember.Comments => BaseProperty?.Comments ?? BaseField?.Comments;

        public CodeTypeMember GetCodeTypeMember() => PrimaryMember;

        #endregion

        #region < Boolean Properties >

        /// <summary> Flag for if the property is a serializable (Determined by attribute above the property) </summary>
        public bool IsSerializable
        {
            get
            {
                if (!IsPublic) return false;
                if (this.BaseProperty.CustomAttributes.Count == 0) return true;
                foreach (CodeAttributeDeclaration attr in this.BaseProperty.CustomAttributes)
                    if (attr.Name.Contains("XmlIgnoreAttribute")) return false;
                return true;
            }
        }

        /// <inheritdoc cref="CodeMemberProperty.HasSet"/>
        public bool HasSetter => BaseProperty?.HasSet ?? BaseField != null;

        /// <summary> If TRUE: The Member is a Property </summary>
        public bool IsProperty => BaseProperty != null;

        /// <summary> If TRUE: The Member is a Field </summary>
        public bool IsField => !IsProperty;
        public bool IsArrayType => Type?.ArrayRank >= 1;
        public bool IsPublic => Attributes == MemberAttributes.Public;
        public bool IsPrivate => Attributes == MemberAttributes.Private;

        /// <summary> Is this property of a type that was generated by xsd.exe </summary>
        internal bool IsGeneratedType => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.Name == this.Type.BaseType);

        /// <summary> Is this property of an ENUM type that was generated by xsd.exe </summary>
        internal bool IsGeneratedEnum => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.IsEnum && d.Name == this.Type.BaseType);

        /// <summary> Is this property of an CLASS type that was generated by xsd.exe </summary>
        internal bool IsGeneratedClass => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.IsClass && d.Name == this.Type.BaseType);

        #endregion < Properties >

        // https://docs.microsoft.com/en-us/dotnet/api/system.codedom.codeexpressionstatement?view=windowsdesktop-5.0
        /// <summary>
        /// Getthe Initializer for this Property / Field for use inthe Supplement's constructor
        /// </summary>
        internal protected virtual CodeAssignStatement GetSupplementInitializer()
        {
            
            CodeExpression left = new CodeVariableReferenceExpression(this.Name);
            CodeExpression right;
            if (IsArrayType)
            {
                switch (this.Type.BaseType.ToLower())
                {
                    case "string": right = new CodeArrayCreateExpression(typeof(string), 0); break;
                    case "int": right = new CodeArrayCreateExpression(typeof(int), 0); break;
                    case "long": right = new CodeArrayCreateExpression(typeof(long), 0); break;
                    case "bool": right = new CodeArrayCreateExpression(typeof(bool), 0); break;
                    case "double": right = new CodeArrayCreateExpression(typeof(double), 0); break;
                    case "float":
                    case "single": right = new CodeArrayCreateExpression(typeof(float), 0); break;
                    default:
                        if (IsGeneratedType)
                            right = new CodeArrayCreateExpression(this.Type, 0);
                        else
                            right = new CodePrimitiveExpression(null);
                        break;
                }
            }
            else
            {
                switch (this.Type.BaseType.ToLower())
                {
                    case "string": right = new CodePrimitiveExpression(String.Empty); break;
                    case "bool": right = new CodePrimitiveExpression(false); break;
                    case "float":
                    case "single":
                    case "double":
                    case "int":
                    case "long": right = new CodePrimitiveExpression(0); break;
                    default:
                        if (IsGeneratedType && IsGeneratedEnum)
                        {
                            DiscoveredEnum @enum = this.ParentClass.ParsedFile.FindEnumByName(this.Type.BaseType);
                            right = (@enum.GetDefaultAssignmentExpression);
                        }
                        else if (IsGeneratedType && IsGeneratedClass)
                            right = new CodeObjectCreateExpression(this.Type);
                        else
                            right = new CodePrimitiveExpression(null);
                        break;
                }
            }
            return new CodeAssignStatement(left,right);
        }

    }
}
