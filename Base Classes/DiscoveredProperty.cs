using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.CodeDom;
using System.CodeDom.Compiler;

namespace XSDCustomToolVSIX.BaseClasses
{
    /// <summary>
    /// Represents the discovered Property of a class
    /// </summary>
    internal class DiscoveredProperty
    {
        private DiscoveredProperty() { }

        internal DiscoveredProperty(CodeMemberProperty ClassMember, CodeMemberField BackingField, DiscoveredClass @ParentClass)
        {
            BaseProperty = ClassMember;
            BaseField = BackingField;
            ParentClassField = @ParentClass;
        }

        #region < Properties >

        
        private readonly CodeMemberProperty BaseProperty;
        private readonly CodeMemberField BaseField;
        private readonly DiscoveredClass ParentClassField;


        /// <summary></summary>
        /// <remarks><inheritdoc cref="CodeTypeMember.Attributes" path="*"/></remarks>
        internal MemberAttributes Attributes => BaseProperty?.Attributes ?? BaseField.Attributes;

        internal bool IsPublic => Attributes == MemberAttributes.Public;
        internal bool IsPrivate => Attributes == MemberAttributes.Private;

        ///<inheritdoc cref="CodeTypeMember.Name"/>
        internal string Name => BaseProperty?.Name ?? BaseField?.Name ?? "UNKOWN";

        ///<inheritdoc cref="CodeTypeReference.BaseType"/>
        internal string Type => CodeTypeReference.BaseType ?? "UNKOWN_TYPE";

        private CodeTypeReference CodeTypeReference => BaseProperty?.Type ?? BaseField?.Type;

        internal bool IsArrayType => CodeTypeReference?.ArrayRank >= 1;

        /// <inheritdoc cref="CodeMemberProperty.HasSet"/>
        internal bool HasSetter => BaseProperty?.HasSet ?? BaseField != null;

        /// <summary> If TRUE: The Member is a Property </summary>
        internal bool IsProperty => BaseProperty != null;
        
        /// <summary> If TRUE: The Member is a Field </summary>
        internal bool IsField => !IsProperty;

        internal protected DiscoveredClass ParentClass
        {
            get => ParentClassField;
        }

        /// <summary> Flag for if the property is a serializable (Determined by attribute above the property) </summary>
        internal bool IsSerializable {
            get
            {
                if (!IsPublic) return false;
                if (this.BaseProperty.CustomAttributes.Count == 0) return true;
                foreach (CodeAttributeDeclaration attr in this.BaseProperty.CustomAttributes)
                    if (attr.Name.Contains("XmlIgnoreAttribute")) return false;
                return true;
            }
        }
        
        #endregion < Properties >

        #region < Boolean Properties >
        
        /// <summary> Is this property of a type that was generated by xsd.exe </summary>
        internal bool IsGeneratedType => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.Name == this.Type);

        /// <summary> Is this property of an ENUM type that was generated by xsd.exe </summary>
        internal bool IsGeneratedEnum => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.IsEnum && d.Name == this.Type);

        /// <summary> Is this property of an CLASS type that was generated by xsd.exe </summary>
        internal bool IsGeneratedClass => this.ParentClass.ParsedFile.DiscoveredTypes.Any((CodeTypeDeclaration d) => d.IsClass && d.Name == this.Type);

        #endregion < Properties >

        // https://docs.microsoft.com/en-us/dotnet/api/system.codedom.codeexpressionstatement?view=windowsdesktop-5.0
        /// <summary>
        /// Getthe Initializer for this Property / Field for use inthe Supplement's constructor
        /// </summary>
        internal protected virtual CodeAssignStatement GetSupplementInitializer()
        {
            
            CodeExpression left = new CodeVariableReferenceExpression(this.Name);
            CodeExpression right;
            if (IsArrayType)
            {
                switch (this.Type.ToLower())
                {
                    case "string": right = new CodeArrayCreateExpression(typeof(string), 0); break;
                    case "int": right = new CodeArrayCreateExpression(typeof(int), 0); break;
                    case "long": right = new CodeArrayCreateExpression(typeof(long), 0); break;
                    case "bool": right = new CodeArrayCreateExpression(typeof(bool), 0); break;
                    case "double": right = new CodeArrayCreateExpression(typeof(double), 0); break;
                    case "float":
                    case "single": right = new CodeArrayCreateExpression(typeof(float), 0); break;
                    default:
                        if (IsGeneratedType)
                            right = new CodeArrayCreateExpression(this.CodeTypeReference, 0);
                        else
                            right = new CodePrimitiveExpression(null);
                        break;
                }
            }
            else
            {
                switch (this.Type.ToLower())
                {
                    case "string": right = new CodePrimitiveExpression(String.Empty); break;
                    case "bool": right = new CodePrimitiveExpression(false); break;
                    case "float":
                    case "single":
                    case "double":
                    case "int":
                    case "long": right = new CodePrimitiveExpression(0); break;
                    default:
                        if (IsGeneratedType && IsGeneratedEnum)
                        {
                            DiscoveredEnum @enum = this.ParentClass.ParsedFile.FindEnumByName(this.Type);
                            right = (@enum.GetDefaultAssignmentExpression);
                        }
                        else if (IsGeneratedType && IsGeneratedClass)
                            right = new CodeObjectCreateExpression(this.Type);
                        else
                            right = new CodePrimitiveExpression(null);
                        break;
                }
            }
            return new CodeAssignStatement(left,right);
        }
    }
}
